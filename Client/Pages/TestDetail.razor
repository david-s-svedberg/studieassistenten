@page "/test/{TestId:int}"
@attribute [Authorize]
@using StudieAssistenten.Shared.DTOs
@using StudieAssistenten.Shared.Enums
@using StudieAssistenten.Client.Services
@using static StudieAssistenten.Client.Shared.FlashcardOptionsDialog
@using static StudieAssistenten.Client.Shared.PracticeTestOptionsDialog
@using static StudieAssistenten.Client.Shared.SummaryOptionsDialog
@inject ITestService TestService
@inject IDocumentService DocumentService
@inject ContentGenerationService ContentService
@inject NavigationManager Navigation
@inject IJSRuntime JS
@inject HttpClient Http
@inject IToastService ToastService

<PageTitle>@(test?.Name ?? "Test")</PageTitle>

@if (isLoading)
{
    <div class="text-center py-5">
        <div class="spinner-border text-light" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
    </div>
}
else if (test == null)
{
    <div class="alert alert-danger">
        <h4>Test not found</h4>
        <p>The test you're looking for doesn't exist.</p>
        <button class="btn btn-primary" @onclick='() => Navigation.NavigateTo("/")'>Go Home</button>
    </div>
}
else
{
    <div class="test-detail">
        <div class="test-header">
            <div class="d-flex justify-content-between align-items-start mb-3">
                <div class="flex-grow-1">
                    @if (isEditingName)
                    {
                        <input type="text" class="form-control form-control-lg bg-dark text-light border-secondary"
                               @bind="editedName"
                               @onblur="SaveName"
                               @onkeydown="HandleNameKeyPress" />
                    }
                    else
                    {
                        <h1 class="test-title" @onclick="StartEditingName" style="cursor: pointer;" title="Click to edit">
                            @test.Name <i class="bi bi-pencil-fill ms-2" style="font-size: 1rem;"></i>
                        </h1>
                    }
                    @if (!string.IsNullOrEmpty(test.Description))
                    {
                        <p class="text-muted">@test.Description</p>
                    }
                </div>
            </div>

            @if (!string.IsNullOrEmpty(test.Instructions))
            {
                <div class="alert alert-info">
                    <strong>AI Instructions:</strong> @test.Instructions
                </div>
            }
        </div>

        @* 2. GENERATED CONTENT SECTION *@
        @if (generatedContents.Any())
        {
            <div class="generated-content-section mb-4">
                <h3 class="mb-3">Generated Content (@generatedContents.Count)</h3>
                <div class="content-grid">
                    @foreach (var content in generatedContents)
                    {
                        <div class="content-card">
                            <div class="content-icon">
                                <i class="bi @GetContentIcon(content.ProcessingType)"></i>
                            </div>
                            <div class="content-info flex-grow-1">
                                <div class="content-title">@content.Title</div>
                                <div class="content-meta">
                                    @content.ProcessingType • @content.GeneratedAt.ToString("yyyy-MM-dd HH:mm")
                                </div>
                            </div>
                            <a href="@ContentService.GetPdfUrl(content.Id)" target="_blank" class="btn btn-sm btn-outline-primary">
                                <i class="bi bi-download"></i> PDF
                            </a>
                        </div>
                    }
                </div>
            </div>
        }

        @* 3. GENERATION BUTTONS (only if all documents have completed OCR) *@
        @if (test.DocumentCount > 0 && documents.All(d => d.Status == DocumentStatus.OcrCompleted || !string.IsNullOrWhiteSpace(d.ExtractedText)))
        {
            @if (isGenerating)
            {
                <div class="alert alert-info mb-4">
                    <div class="d-flex align-items-center">
                        <div class="spinner-border spinner-border-sm me-2" role="status"></div>
                        <span>Generating @generatingType with AI... This may take a moment.</span>
                    </div>
                </div>
            }

            <div class="test-actions mb-4">
                @if (generatedContents.Any())
                {
                    <h4>Generate More Content</h4>
                }
                else
                {
                    <h4>Generate Content</h4>
                }
                <div class="generation-buttons">
                    <button class="btn btn-success" @onclick="GenerateFlashcards" disabled="@isGenerating">
                        @if (isGenerating && generatingType == ProcessingType.Flashcards)
                        {
                            <span class="spinner-border spinner-border-sm me-2"></span>
                        }
                        <i class="bi bi-card-list"></i> Generate Flashcards
                    </button>
                    <button class="btn btn-info" @onclick="GeneratePracticeTest" disabled="@isGenerating">
                        @if (isGenerating && generatingType == ProcessingType.PracticeTest)
                        {
                            <span class="spinner-border spinner-border-sm me-2"></span>
                        }
                        <i class="bi bi-file-text"></i> Generate Practice Test
                    </button>
                    <button class="btn btn-warning" @onclick="GenerateSummary" disabled="@isGenerating">
                        @if (isGenerating && generatingType == ProcessingType.Summary)
                        {
                            <span class="spinner-border spinner-border-sm me-2"></span>
                        }
                        <i class="bi bi-file-earmark-text"></i> Generate Summary
                    </button>
                </div>
            </div>
        }

        @* 4. UPLOADED DOCUMENTS SECTION *@
        @if (test.Documents != null && test.Documents.Any())
        {
            <div class="documents-section mb-2">
                <h3 class="mb-3">Uploaded Documents (@test.DocumentCount)</h3>
                <div class="document-grid">
                    @foreach (var doc in documents)
                    {
                        <div class="document-card" @onclick='() => ViewDocument(doc.Id)'>
                            <div class="document-icon">
                                <i class="bi @GetFileIcon(doc.FileName)"></i>
                            </div>
                            <div class="document-info">
                                <div class="document-name">@doc.FileName</div>
                                <div class="document-meta">
                                    @FormatFileSize(doc.FileSizeBytes) • @doc.Status
                                </div>
                            </div>
                        </div>
                    }
                </div>
            </div>
        }
        else
        {
            <div class="no-documents-message mb-2">
                <i class="bi bi-inbox" style="font-size: 2rem; color: #8e8ea0;"></i>
                <p class="text-muted mt-2 mb-0">No documents uploaded yet. Upload your first document below!</p>
            </div>
        }

        @* Upload Component - Always visible at bottom *@
        <div class="upload-section mt-3">
            <h3>Add Content</h3>

            @* Tab Selector *@
            <div class="content-tabs">
                <button class="tab-btn @(uploadMode == "files" ? "active" : "")"
                        @onclick='() => uploadMode = "files"'>
                    <i class="bi bi-cloud-upload"></i> Upload Files
                </button>
                <button class="tab-btn @(uploadMode == "text" ? "active" : "")"
                        @onclick='() => uploadMode = "text"'>
                    <i class="bi bi-pencil-square"></i> Enter Text
                </button>
            </div>

            @if (uploadMode == "files" && isUploading)
            {
                <div class="upload-area">
                    <div class="text-center py-5">
                        <div class="spinner-border text-light mb-3" role="status"></div>
                        <div>
                            <p class="text-light mb-2">@uploadStatus</p>
                            @if (isProcessingOcr)
                            {
                                <small class="text-muted">Processing with OCR...</small>
                            }
                            @if (namingInProgress)
                            {
                                <small class="text-muted d-block mt-2">
                                    Generating test name<span class="loading-dots"></span>
                                </small>
                            }
                        </div>
                    </div>
                </div>
            }
            else if (uploadMode == "files")
            {
                <div class="upload-area">
                    <p class="text-muted mb-3">PDF, Images, Text files (Max 60MB each)</p>

                    <div class="file-input-wrapper">
                        <InputFile id="fileInput"
                                  OnChange="@HandleFileSelected"
                                  class="file-input"
                                  accept="image/*,.pdf,.jpg,.jpeg,.png,.txt,.docx"
                                  multiple />
                        <label for="fileInput" class="btn btn-primary add-content-btn">
                            <i class="bi bi-plus-circle me-2"></i>
                            Add Content
                        </label>
                    </div>

                    @* Show queued files if any *@
                    @if (selectedFiles.Any())
                    {
                        <div class="queued-files-section mt-3">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <h5 class="mb-0">Queued Files (@selectedFiles.Count)</h5>
                                <button class="btn btn-sm btn-outline-secondary" @onclick="ClearQueue">
                                    <i class="bi bi-x-circle me-1"></i>Clear All
                                </button>
                            </div>
                            <div class="queued-files-grid">
                                @foreach (var file in selectedFiles)
                                {
                                    <div class="queued-file-card">
                                        <button class="btn-remove-file" @onclick="() => RemoveFile(file)" title="Remove">
                                            <i class="bi bi-x-circle-fill"></i>
                                        </button>
                                        <div class="file-preview">
                                            <i class="bi @GetFileIcon(file.Name)"></i>
                                        </div>
                                        <div class="file-details">
                                            <div class="file-name-small">@file.Name</div>
                                            <div class="file-size-small">@FormatFileSize(file.Size)</div>
                                        </div>
                                    </div>
                                }
                            </div>
                            <button class="btn btn-success w-100 mt-3" @onclick="UploadFiles">
                                <i class="bi bi-cloud-upload me-2"></i>Upload & Process All (@selectedFiles.Count files)
                            </button>
                        </div>
                    }

                    @if (!string.IsNullOrEmpty(uploadErrorMessage))
                    {
                        <div class="alert alert-danger mt-3">
                            <i class="bi bi-exclamation-triangle"></i> @uploadErrorMessage
                        </div>
                    }
                </div>
            }
            else if (uploadMode == "text")
            {
                <div class="text-input-area">
                    <textarea class="form-control text-input-box"
                              @bind="textContent"
                              placeholder="Type or paste your study material here...&#10;&#10;You can paste notes, lecture transcripts, or any text content you want to study from."
                              rows="12"></textarea>

                    @if (!string.IsNullOrWhiteSpace(textContentError))
                    {
                        <div class="alert alert-danger mt-2">@textContentError</div>
                    }

                    <div class="text-input-actions">
                        <input type="text"
                               class="form-control document-name-input"
                               @bind="textDocumentName"
                               placeholder="Document name (optional)" />
                        <button class="btn btn-primary"
                                @onclick="UploadTextContent"
                                disabled="@(string.IsNullOrWhiteSpace(textContent) || isUploadingText)">
                            @if (isUploadingText)
                            {
                                <span class="spinner-border spinner-border-sm me-2"></span>
                                <text>Uploading...</text>
                            }
                            else
                            {
                                <i class="bi bi-upload me-2"></i>
                                <text>Add Text Document</text>
                            }
                        </button>
                    </div>
                </div>
            }
        </div>
    </div>
}

@* Option Dialogs *@
@if (showFlashcardDialog)
{
    <FlashcardOptionsDialog OnConfirm="HandleFlashcardOptions" OnCancel="CloseDialogs" />
}

@if (showPracticeTestDialog)
{
    <PracticeTestOptionsDialog OnConfirm="HandlePracticeTestOptions" OnCancel="CloseDialogs" />
}

@if (showSummaryDialog)
{
    <SummaryOptionsDialog OnConfirm="HandleSummaryOptions" OnCancel="CloseDialogs" />
}

<style>
    .test-detail {
        color: #ececf1;
    }

    .test-title {
        color: #ececf1;
        font-size: 2rem;
        font-weight: 600;
        margin-bottom: 0.5rem;
    }

    .test-actions h4 {
        color: #ececf1;
        font-size: 1.25rem;
        margin-bottom: 1rem;
    }

    .generation-buttons {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
    }

    .no-documents-message {
        text-align: center;
        padding: 1rem 2rem;
        background: #343541;
        border-radius: 1rem;
    }

    .documents-section h3,
    .generated-content-section h3 {
        color: #ececf1;
    }

    .document-grid, .content-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
        gap: 1rem;
    }

    .document-card, .content-card {
        background: #444654;
        border: 1px solid #565869;
        border-radius: 0.5rem;
        padding: 1rem;
        transition: all 0.2s;
        display: flex;
        gap: 1rem;
        align-items: center;
    }

    .document-card {
        cursor: pointer;
    }

    .document-card:hover {
        background: #565869;
        transform: translateY(-2px);
    }

    .content-card {
        background: #2d3748;
        border-color: #4a5568;
    }

    .document-icon, .content-icon {
        font-size: 2rem;
    }

    .document-icon {
        color: #10a37f;
    }

    .content-icon {
        color: #3b82f6;
    }

    .document-info, .content-info {
        flex: 1;
        min-width: 0;
    }

    .document-name, .content-title {
        font-weight: 500;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        color: #ececf1;
    }

    .document-meta, .content-meta {
        font-size: 0.875rem;
        color: #8e8ea0;
        margin-top: 0.25rem;
    }

    /* Upload component styles */
    .upload-section {
        background: #2a2b32;
        border-radius: 1rem;
        padding: 1.5rem;
    }

    .upload-section h3 {
        color: #ececf1;
        margin-bottom: 1rem;
    }

    .content-tabs {
        display: flex;
        gap: 0.5rem;
        margin-bottom: 1.5rem;
        border-bottom: 2px solid #444654;
    }

    .tab-btn {
        padding: 0.75rem 1.5rem;
        background: none;
        border: none;
        border-bottom: 3px solid transparent;
        cursor: pointer;
        font-size: 1rem;
        color: #ececf1;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .tab-btn:hover {
        color: #10b981;
        background: rgba(16, 185, 129, 0.1);
    }

    .tab-btn.active {
        color: #10b981;
        border-bottom-color: #10b981;
        font-weight: 600;
    }

    @@media (max-width: 768px) {
        .content-tabs {
            flex-direction: column;
            gap: 0;
        }

        .tab-btn {
            width: 100%;
            justify-content: center;
            border-bottom: 1px solid #444654;
            padding: 1rem;
        }

        .tab-btn.active {
            background: rgba(16, 185, 129, 0.15);
        }
    }

    .text-input-area {
        background: #444654;
        border-radius: 1rem;
        padding: 1.5rem;
    }

    .text-input-box {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        font-size: 1rem;
        line-height: 1.6;
        resize: vertical;
        min-height: 300px;
        background: #2a2b32;
        border: 1px solid #565869;
        color: #ececf1;
    }

    .text-input-box:focus {
        background: #2a2b32;
        border-color: #10b981;
        color: #ececf1;
        box-shadow: 0 0 0 0.25rem rgba(16, 185, 129, 0.25);
    }

    .text-input-actions {
        display: flex;
        gap: 1rem;
        margin-top: 1rem;
        align-items: center;
    }

    .document-name-input {
        flex: 1;
        max-width: 300px;
        background: #2a2b32;
        border: 1px solid #565869;
        color: #ececf1;
    }

    .document-name-input:focus {
        background: #2a2b32;
        border-color: #10b981;
        color: #ececf1;
        box-shadow: 0 0 0 0.25rem rgba(16, 185, 129, 0.25);
    }

    @@media (max-width: 768px) {
        .text-input-actions {
            flex-direction: column;
            align-items: stretch;
        }

        .document-name-input {
            max-width: 100%;
        }

        .text-input-box {
            min-height: 200px;
        }
    }

    .upload-area {
        background: #444654;
        border-radius: 1rem;
        padding: 2rem;
    }

    .file-input-wrapper {
        position: relative;
        display: inline-block;
    }

    .file-input {
        position: absolute;
        opacity: 0;
        width: 0;
        height: 0;
    }

    .add-content-btn {
        cursor: pointer;
        padding: 0.75rem 2rem;
        font-size: 1rem;
    }

    .queued-files-section {
        background: #343541;
        border-radius: 0.75rem;
        padding: 1.5rem;
        margin-bottom: 1rem;
    }

    .queued-files-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        gap: 1rem;
        margin-top: 1rem;
    }

    .queued-file-card {
        position: relative;
        background: #444654;
        border-radius: 0.5rem;
        padding: 1rem;
        text-align: center;
        transition: all 0.2s;
    }

    .queued-file-card:hover {
        background: #4f5060;
    }

    .btn-remove-file {
        position: absolute;
        top: -8px;
        right: -8px;
        background: #ef4444;
        border: 2px solid #343541;
        border-radius: 50%;
        width: 28px;
        height: 28px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        color: white;
        font-size: 16px;
        transition: all 0.2s;
        padding: 0;
    }

    .btn-remove-file:hover {
        background: #dc2626;
        transform: scale(1.1);
    }

    .file-preview {
        font-size: 2.5rem;
        color: #8e8ea0;
        margin-bottom: 0.5rem;
    }

    .file-name-small {
        font-size: 0.75rem;
        color: #ececf1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        margin-bottom: 0.25rem;
    }

    .file-size-small {
        font-size: 0.65rem;
        color: #8e8ea0;
    }

    /* Animated loading dots */
    .loading-dots::after {
        content: '';
        animation: dots 1.5s steps(4, end) infinite;
    }

    @@keyframes dots {
        0%, 20% { content: ''; }
        40% { content: '.'; }
        60% { content: '..'; }
        80%, 100% { content: '...'; }
    }
</style>

@code {
    [Parameter]
    public int TestId { get; set; }

    private TestDto? test;
    private List<DocumentDto> documents = new();
    private List<GeneratedContentDto> generatedContents = new();
    private bool isLoading = true;
    private bool isGenerating = false;
    private ProcessingType? generatingType = null;
    private bool isEditingName = false;
    private string editedName = "";

    // Dialog state
    private bool showFlashcardDialog = false;
    private bool showPracticeTestDialog = false;
    private bool showSummaryDialog = false;

    // Upload state
    private List<IBrowserFile> selectedFiles = new();
    private List<QueuedFileData> queuedFileData = new(); // Store actual file data
    private bool isUploading = false;
    private bool isProcessingOcr = false;
    private string uploadStatus = "";
    private string? uploadErrorMessage;
    private string uploadMode = "files"; // "files" or "text"

    // Helper class to store file data in memory
    private class QueuedFileData
    {
        public MemoryStream Stream { get; set; } = null!;
        public string Name { get; set; } = "";
        public string ContentType { get; set; } = "";
        public long Size { get; set; }
    }

    // Text input state
    private string textContent = "";
    private string textDocumentName = "";
    private bool isUploadingText = false;
    private string? textContentError;

    // Smart naming state
    private bool hasAttemptedNaming = false;
    private bool namingSucceeded = false;
    private bool namingInProgress = false;
    private string? lastFailedNamingReason;

    protected override async Task OnParametersSetAsync()
    {
        await LoadTest();
        await LoadGeneratedContent();
    }

    private async Task LoadTest()
    {
        isLoading = true;
        test = await TestService.GetTestAsync(TestId);

        if (test != null)
        {
            // Load documents for this test
            var allDocs = await DocumentService.GetDocumentsAsync();
            documents = allDocs.Where(d => d.TestId == TestId).ToList();
        }

        isLoading = false;
    }

    private async Task LoadGeneratedContent()
    {
        try
        {
            generatedContents = await ContentService.GetTestContentsAsync(TestId);
        }
        catch
        {
            generatedContents = new();
        }
    }

    private void StartEditingName()
    {
        if (test != null)
        {
            editedName = test.Name;
            isEditingName = true;
        }
    }

    private async Task SaveName()
    {
        if (test != null && !string.IsNullOrWhiteSpace(editedName) && editedName != test.Name)
        {
            var request = new CreateTestRequest
            {
                Name = editedName,
                Description = test.Description,
                Instructions = test.Instructions
            };

            await TestService.UpdateTestAsync(TestId, request);
            test.Name = editedName;
        }

        isEditingName = false;
    }

    private async Task HandleNameKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await SaveName();
        }
        else if (e.Key == "Escape")
        {
            isEditingName = false;
        }
    }

    private void GenerateFlashcards()
    {
        showFlashcardDialog = true;
    }

    private void GeneratePracticeTest()
    {
        showPracticeTestDialog = true;
    }

    private void GenerateSummary()
    {
        showSummaryDialog = true;
    }

    private void CloseDialogs()
    {
        showFlashcardDialog = false;
        showPracticeTestDialog = false;
        showSummaryDialog = false;
    }

    private async Task HandleFlashcardOptions(FlashcardOptions options)
    {
        CloseDialogs();

        var request = new GenerateContentRequestDto
        {
            TestId = test!.Id,
            ProcessingType = ProcessingType.Flashcards,
            NumberOfCards = options.NumberOfCards,
            DifficultyLevel = options.DifficultyLevel
        };

        await GenerateContentWithRequest(request, ProcessingType.Flashcards);
    }

    private async Task HandlePracticeTestOptions(PracticeTestOptions options)
    {
        CloseDialogs();

        var request = new GenerateContentRequestDto
        {
            TestId = test!.Id,
            ProcessingType = ProcessingType.PracticeTest,
            NumberOfQuestions = options.NumberOfQuestions,
            QuestionTypes = options.QuestionTypes,
            IncludeAnswerExplanations = options.IncludeAnswerExplanations
        };

        await GenerateContentWithRequest(request, ProcessingType.PracticeTest);
    }

    private async Task HandleSummaryOptions(SummaryOptions options)
    {
        CloseDialogs();

        var request = new GenerateContentRequestDto
        {
            TestId = test!.Id,
            ProcessingType = ProcessingType.Summary,
            SummaryLength = options.Length,
            SummaryFormat = options.Format
        };

        await GenerateContentWithRequest(request, ProcessingType.Summary);
    }

    private async Task GenerateContentWithRequest(GenerateContentRequestDto request, ProcessingType type)
    {
        if (test == null || documents.Count == 0) return;

        isGenerating = true;
        generatingType = type;

        try
        {
            var result = await ContentService.GenerateContentAsync(request);

            if (result != null)
            {
                // Reload content list
                await LoadGeneratedContent();

                // Show success toast
                ToastService.ShowSuccess($"{type} generated successfully! Click to view PDF.");
            }
            else
            {
                ToastService.ShowError("Failed to generate content. Please try again.");
            }
        }
        catch (Exception ex)
        {
            ToastService.ShowError($"Failed to generate content: {ex.Message}");
        }
        finally
        {
            isGenerating = false;
            generatingType = null;
        }
    }

    private void ViewDocument(int documentId)
    {
        Navigation.NavigateTo($"/document/{documentId}");
    }

    private string GetFileIcon(string fileName)
    {
        var lower = fileName.ToLowerInvariant();
        if (lower.EndsWith(".jpg") || lower.EndsWith(".jpeg") || lower.EndsWith(".png") || lower.EndsWith(".gif")) return "bi-file-image";
        if (lower.EndsWith(".pdf")) return "bi-file-pdf";
        return "bi-file-text";
    }

    private string GetContentIcon(ProcessingType type)
    {
        return type switch
        {
            ProcessingType.Flashcards => "bi-card-list",
            ProcessingType.PracticeTest => "bi-file-text",
            ProcessingType.Summary => "bi-file-earmark-text",
            _ => "bi-file"
        };
    }

    private string FormatFileSize(long bytes)
    {
        if (bytes < 1024) return $"{bytes} B";
        if (bytes < 1024 * 1024) return $"{bytes / 1024} KB";
        return $"{bytes / (1024 * 1024)} MB";
    }

    private async Task UploadTextContent()
    {
        if (test == null || string.IsNullOrWhiteSpace(textContent))
            return;

        textContentError = null;
        isUploadingText = true;

        try
        {
            // Create a filename
            var fileName = string.IsNullOrWhiteSpace(textDocumentName)
                ? $"Text Document - {DateTime.Now:yyyy-MM-dd HH-mm}.txt"
                : $"{textDocumentName}.txt";

            // Convert text to bytes
            var textBytes = System.Text.Encoding.UTF8.GetBytes(textContent);
            using var stream = new MemoryStream(textBytes);

            // Upload as a document
            var document = await DocumentService.UploadDocumentAsync(stream, fileName, "text/plain", textBytes.Length, test.Id);

            if (document != null)
            {
                // For text documents, directly update the ExtractedText in the database
                try
                {
                    await DocumentService.UpdateExtractedTextAsync(document.Id, textContent);
                }
                catch
                {
                    textContentError = "Text uploaded but failed to set content. Try editing the document.";
                }

                // Clear the text input
                textContent = "";
                textDocumentName = "";

                // Reload the test to show the new document
                await LoadTest();

                // Switch back to files tab to show the uploaded document
                uploadMode = "files";
            }
            else
            {
                textContentError = "Failed to upload text content";
            }
        }
        catch (Exception ex)
        {
            textContentError = $"Error: {ex.Message}";
        }
        finally
        {
            isUploadingText = false;
        }
    }

    // Upload methods
    private async void HandleFileSelected(InputFileChangeEventArgs e)
    {
        const long maxFileSize = 60 * 1024 * 1024; // 60 MB
        uploadErrorMessage = null;

        try
        {
            // Read file data immediately before component re-renders
            foreach (var file in e.GetMultipleFiles(20)) // Max 20 files
            {
                // Avoid duplicates
                if (selectedFiles.Any(f => f.Name == file.Name && f.Size == file.Size))
                    continue;

                // Read file data into memory immediately
                using var browserStream = file.OpenReadStream(maxFileSize);
                var memoryStream = new MemoryStream();
                await browserStream.CopyToAsync(memoryStream);
                memoryStream.Position = 0;

                // Store both the file reference (for UI) and the data (for upload)
                selectedFiles.Add(file);
                queuedFileData.Add(new QueuedFileData
                {
                    Stream = memoryStream,
                    Name = file.Name,
                    ContentType = file.ContentType,
                    Size = file.Size
                });
            }
        }
        catch (Exception ex)
        {
            uploadErrorMessage = $"Error reading files: {ex.Message}";
        }

        StateHasChanged();
    }

    private void RemoveFile(IBrowserFile file)
    {
        var index = selectedFiles.IndexOf(file);
        if (index >= 0)
        {
            selectedFiles.RemoveAt(index);

            // Also remove the corresponding queued data and dispose stream
            if (index < queuedFileData.Count)
            {
                queuedFileData[index].Stream.Dispose();
                queuedFileData.RemoveAt(index);
            }
        }
        StateHasChanged();
    }

    private void ClearQueue()
    {
        selectedFiles.Clear();

        // Dispose all streams
        foreach (var data in queuedFileData)
        {
            data.Stream.Dispose();
        }
        queuedFileData.Clear();

        uploadErrorMessage = null;
        StateHasChanged();
    }

    private async Task UploadFiles()
    {
        if (!queuedFileData.Any() || test == null) return;

        try
        {
            isUploading = true;
            StateHasChanged();
            uploadErrorMessage = null;

            // Upload each queued file
            for (int i = 0; i < queuedFileData.Count; i++)
            {
                var fileData = queuedFileData[i];
                uploadStatus = $"Uploading {i + 1} of {queuedFileData.Count}: {fileData.Name}";
                StateHasChanged();

                // Reset stream position before upload
                fileData.Stream.Position = 0;

                var uploadedDoc = await DocumentService.UploadDocumentAsync(
                    fileData.Stream, fileData.Name, fileData.ContentType, fileData.Size, test.Id);

                if (uploadedDoc != null)
                {
                    // Auto-trigger OCR if needed
                    if (uploadedDoc.Status == DocumentStatus.Uploaded &&
                        (uploadedDoc.FileName.EndsWith(".pdf", StringComparison.OrdinalIgnoreCase) ||
                         uploadedDoc.FileName.EndsWith(".jpg", StringComparison.OrdinalIgnoreCase) ||
                         uploadedDoc.FileName.EndsWith(".jpeg", StringComparison.OrdinalIgnoreCase) ||
                         uploadedDoc.FileName.EndsWith(".png", StringComparison.OrdinalIgnoreCase)))
                    {
                        isProcessingOcr = true;
                        uploadStatus = $"Processing OCR for {fileData.Name}...";
                        StateHasChanged();

                        await DocumentService.TriggerOcrProcessingAsync(uploadedDoc.Id);
                        await Task.Delay(2000);
                    }
                }
            }

            // Cleanup
            selectedFiles.Clear();
            foreach (var data in queuedFileData)
            {
                data.Stream.Dispose();
            }
            queuedFileData.Clear();
            isProcessingOcr = false;

            // Reload test to get new documents
            await LoadTest();
            StateHasChanged();

            // SMART NAMING: Only attempt if not already done successfully
            await AttemptSmartNaming();
        }
        catch (Exception ex)
        {
            uploadErrorMessage = $"Upload failed: {ex.Message}";
        }
        finally
        {
            isUploading = false;
            StateHasChanged();
        }
    }

    // Smart test naming methods
    private async Task AttemptSmartNaming()
    {
        if (test == null) return;

        // Check if we should attempt naming
        bool shouldAttempt = !hasAttemptedNaming || // Never tried
                             (hasAttemptedNaming && !namingSucceeded); // Tried but failed

        if (!shouldAttempt)
        {
            return;
        }

        // Don't regenerate if user manually changed the name
        if (IsManuallyNamed())
        {
            hasAttemptedNaming = true;
            namingSucceeded = true; // Treat as success to prevent future attempts
            return;
        }

        try
        {
            hasAttemptedNaming = true;
            namingInProgress = true;
            uploadStatus = "Generating test name...";
            StateHasChanged();

            // Wait for OCR to complete
            bool ocrComplete = await WaitForOcrCompletion();

            if (ocrComplete)
            {
                var suggestedName = await TestService.SuggestTestNameAsync(test.Id);

                if (!string.IsNullOrWhiteSpace(suggestedName) &&
                    !suggestedName.StartsWith("Test - ") &&
                    !suggestedName.StartsWith("New Test - "))
                {
                    // Reload test to get updated name
                    await LoadTest();
                    namingSucceeded = true;
                    lastFailedNamingReason = null;
                    uploadStatus = $"Test renamed to: {suggestedName}";
                }
                else
                {
                    namingSucceeded = false;
                    lastFailedNamingReason = "AI could not generate a suitable name";
                    ToastService.ShowWarning("Could not auto-generate test name. You can edit it manually.");
                }
            }
            else
            {
                namingSucceeded = false;
                lastFailedNamingReason = "OCR timeout";
                ToastService.ShowWarning("OCR is taking longer than expected. Test name not generated.");
            }
        }
        catch (Exception ex)
        {
            namingSucceeded = false;
            lastFailedNamingReason = ex.Message;
            ToastService.ShowError($"Error generating test name: {ex.Message}");
        }
        finally
        {
            namingInProgress = false;
            StateHasChanged();
        }
    }

    private bool IsManuallyNamed()
    {
        if (test == null || string.IsNullOrEmpty(test.Name)) return false;

        // Check if name is still the default date-based format
        return !test.Name.StartsWith("Test - ") &&
               !test.Name.StartsWith("New Test - ");
    }

    private async Task<bool> WaitForOcrCompletion()
    {
        if (test == null) return false;

        int maxAttempts = 30; // 30 seconds max
        int attempts = 0;

        while (attempts < maxAttempts)
        {
            await Task.Delay(1000);
            attempts++;

            var updatedTest = await TestService.GetTestAsync(test.Id);
            if (updatedTest?.Documents != null)
            {
                var completedDocs = updatedTest.Documents.Count(d =>
                    d.Status == DocumentStatus.OcrCompleted ||
                    !string.IsNullOrWhiteSpace(d.ExtractedText));

                if (completedDocs > 0)
                {
                    return true;
                }
            }
        }

        return false;
    }

}
